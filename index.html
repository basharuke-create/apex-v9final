<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>APEX Ω – ULTIMA</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#05050a;--card:#0d0d18;--border:#1a1a2e;
  --g:#00ffaa;--r:#ff5e5e;--t:#cfd8ff;--d:#8892b0;--y:#f5c400;
  --g-dim:rgba(0,255,170,.06);--g-border:rgba(0,255,170,.35);
  --r-dim:rgba(255,94,94,.06);--r-border:rgba(255,94,94,.35);
  --y-dim:rgba(245,196,0,.06);--y-border:rgba(245,196,0,.35);
}
body{
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:radial-gradient(circle at top,#16162a 0,#05050a 60%);
  color:var(--t);padding:16px;
}
.shell{max-width:1100px;margin:auto}
.card{
  background:var(--card);border:1px solid var(--border);
  border-radius:14px;padding:14px;margin-bottom:14px;
  box-shadow:0 20px 50px rgba(0,0,0,.6);
}
h1{font-size:1.2rem;margin-bottom:8px}
textarea{
  width:100%;min-height:90px;
  background:#070712;color:var(--t);
  border:1px solid var(--border);border-radius:10px;
  padding:10px;resize:vertical;font-size:.9rem;
}
textarea:focus,input:focus{outline:none;border-color:rgba(0,255,170,.4)}
input{
  width:100%;padding:8px;margin-top:6px;
  border-radius:8px;border:1px solid #333;
  background:#070712;color:#fff;font-size:.9rem;
  transition:border-color .2s;
}
button{
  border:none;border-radius:999px;
  padding:8px 18px;margin-top:8px;
  cursor:pointer;font-weight:600;font-size:.85rem;
  transition:opacity .2s;
}
button:disabled{opacity:.4;cursor:not-allowed}
.main{background:linear-gradient(135deg,#00ffaa,#4df3ff);color:#000}
.ghost{background:transparent;border:1px solid #333;color:#aaa;margin-left:8px}
.ghost:hover:not(:disabled){border-color:#666;color:#ccc}

.status{
  font-size:.8rem;margin-top:8px;padding:7px 11px;
  border-radius:7px;min-height:32px;line-height:1.5;
  border:1px solid transparent;
}
.status.ok  {color:var(--g);background:var(--g-dim);border-color:var(--g-border)}
.status.warn{color:var(--y);background:var(--y-dim);border-color:var(--y-border)}
.status.err {color:var(--r);background:var(--r-dim);border-color:var(--r-border)}

#cd-wrap{
  display:none;align-items:center;gap:10px;
  margin-top:8px;font-size:.8rem;color:var(--d);
}
#cd-wrap.show{display:flex}
#cd-num{font-weight:700;color:var(--y);min-width:32px}
#cd-track{flex:1;height:3px;background:var(--border);border-radius:2px;overflow:hidden}
#cd-fill{height:3px;background:var(--y)}

.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;margin-top:10px}
.agent{background:#080814;border:1px solid #1e1e30;padding:10px;border-radius:10px;min-height:80px}
.agent-title{font-size:.72rem;letter-spacing:.1em;margin-bottom:6px;color:var(--d);text-transform:uppercase}
.agent-body{font-size:.85rem;white-space:pre-wrap;line-height:1.65;color:var(--t)}
.agent-body:empty::after,.agent-body.loading::after{
  content:'—';color:var(--d);
}
.agent-body.loading::after{content:'';animation:dots 1.2s infinite}
@keyframes dots{0%{content:''}25%{content:'.'}50%{content:'..'}75%{content:'...'}100%{content:''}}

.omega{
  margin-top:12px;
  border:1px solid var(--g-border);
  padding:14px;border-radius:10px;
  background:var(--g-dim);
}
.omega .agent-title{color:var(--g)}
.meta{font-size:.72rem;color:#444;margin-top:10px}
</style>
</head>
<body>
<div class="shell">

  <div class="card">
    <h1>APEX Ω – ULTIMA</h1>
    <input type="password" id="key" placeholder="Gemini API Key（保存されません）— aistudio.google.com で取得">
    <textarea id="q" placeholder="意思決定・問題・戦略課題を入力..."></textarea>
    <button id="run_btn" class="main" onclick="run()">▶ 実行</button>
    <button class="ghost" onclick="clearCache()">キャッシュ削除</button>
    <div id="status" class="status"></div>
    <div id="cd-wrap">
      <span>待機中</span>
      <span id="cd-num"></span>
      <span>秒</span>
      <div id="cd-track"><div id="cd-fill"></div></div>
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div class="agent"><div class="agent-title">α 戦略</div><div id="el_a" class="agent-body"></div></div>
      <div class="agent"><div class="agent-title">β 実務</div><div id="el_b" class="agent-body"></div></div>
      <div class="agent"><div class="agent-title">γ 批評</div><div id="el_c" class="agent-body"></div></div>
      <div class="agent"><div class="agent-title">δ 原理</div><div id="el_d" class="agent-body"></div></div>
    </div>
    <div class="omega">
      <div class="agent-title">Ω 統合判断</div>
      <div id="el_o" class="agent-body"></div>
    </div>
    <div class="meta" id="meta"></div>
  </div>

</div>
<script>
'use strict';

/* ─── CONFIG ──────────────────────────────────────────────
   2 API calls total per run → physically impossible to hit 15/min limit
   CALL_GAP enforces minimum spacing as a secondary safeguard             */
const ENDPOINT  = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';
const CALL_GAP  = 9000;   // ms between calls (= max 6.7 req/min)
const WAIT_429  = 95;     // s to wait on 429 before retry (Gemini window = ~90s)
const MAX_RETRY = 2;      // max 429 retries per call
const CACHE_TTL = 7 * 24 * 60 * 60 * 1000;
const CACHE_MAX = 50;
const PFX       = 'apex_';

/* ─── STATE ───────────────────────────────────────────── */
let running    = false;
let lastCallAt = 0;
let callCount  = 0;
let cdInterval = null;

/* ─── DOM ─────────────────────────────────────────────── */
const $  = id => document.getElementById(id);
const el = {
  key:    () => $('key').value.trim(),
  q:      () => $('q').value.trim().replace(/[<>]/g,''),
  status: $('status'),
  meta:   $('meta'),
  btn:    $('run_btn'),
  agents: { a:'el_a', b:'el_b', c:'el_c', d:'el_d', o:'el_o' }
};

function setStatus(msg, type='') {
  el.status.textContent = msg;
  el.status.className   = 'status' + (type ? ' '+type : '');
}

function setLoading(id) {
  $(id).textContent = '';
  $(id).className   = 'agent-body loading';
}
function setText(id, txt) {
  $(id).textContent = txt || '';
  $(id).className   = 'agent-body';
}

/* ─── COUNTDOWN ───────────────────────────────────────── */
function startCd(sec) {
  const wrap = $('cd-wrap'), num = $('cd-num'), fill = $('cd-fill');
  if(cdInterval) clearInterval(cdInterval);
  wrap.classList.add('show');
  let r = sec;
  num.textContent = r;
  fill.style.transition = 'none';
  fill.style.width = '100%';
  void fill.offsetWidth;
  fill.style.transition = `width ${sec}s linear`;
  fill.style.width = '0%';
  cdInterval = setInterval(() => {
    r--;
    num.textContent = Math.max(0, r);
    if(r <= 0) stopCd();
  }, 1000);
}
function stopCd() {
  if(cdInterval) { clearInterval(cdInterval); cdInterval = null; }
  $('cd-wrap').classList.remove('show');
}

/* ─── CACHE ───────────────────────────────────────────── */
function cacheGet(k) {
  try {
    const raw = localStorage.getItem(k);
    if(!raw) return null;
    const d = JSON.parse(raw);
    if(Date.now() - d.t > CACHE_TTL) { localStorage.removeItem(k); return null; }
    d.last = Date.now();
    localStorage.setItem(k, JSON.stringify(d));
    return d.v;
  } catch(_) { return null; }
}
function cacheSet(k, v) {
  try {
    const keys = Object.keys(localStorage).filter(x => x.startsWith(PFX));
    if(keys.length >= CACHE_MAX) {
      const oldest = keys
        .map(k => [k, (JSON.parse(localStorage.getItem(k)) || {last:0}).last])
        .sort((a,b) => a[1]-b[1])[0][0];
      localStorage.removeItem(oldest);
    }
    localStorage.setItem(k, JSON.stringify({ t:Date.now(), last:Date.now(), v }));
  } catch(_) {}
}
function clearCache() {
  Object.keys(localStorage).filter(k => k.startsWith(PFX)).forEach(k => localStorage.removeItem(k));
  setStatus('キャッシュを削除しました', 'ok');
}

/* ─── JSON PARSER (4-stage repair) ───────────────────── */
function safeJSON(text) {
  if(!text) return null;
  const strip = s => s.replace(/^```(?:json)?\s*/im,'').replace(/\s*```\s*$/,'').trim();
  // Stage 1: direct
  try { return JSON.parse(text); } catch(_) {}
  // Stage 2: strip markdown fences
  try { return JSON.parse(strip(text)); } catch(_) {}
  // Stage 3: extract outermost {...}
  const m = text.match(/\{[\s\S]*\}/);
  if(m) {
    try { return JSON.parse(m[0]); } catch(_) {}
    // Stage 4: fix trailing commas + unquoted keys
    try {
      return JSON.parse(
        m[0]
          .replace(/,\s*([}\]])/g, '$1')
          .replace(/([{,]\s*)(\w+)\s*:/g, '$1"$2":')
      );
    } catch(_) {}
  }
  console.warn('[APEX] safeJSON failed. Raw text:', text.slice(0, 400));
  return null;
}

/* ─── VALIDATE: ensure Gemini filled in real content ─── */
// These are the template strings we sent — if returned unchanged, it's a failure
const PLACEHOLDERS = [
  '戦略的視点からの分析',
  '実務的視点からの分析',
  '批評的視点からの分析',
  '原理的視点からの分析',
];
function isPlaceholder(str) {
  return PLACEHOLDERS.some(p => str.trim() === p || str.trim().startsWith(p + '（'));
}

/* ─── API CALL (fixed-gap + 429 recovery) ────────────── */
async function callGemini(prompt) {
  const key = el.key();
  if(!key) throw new Error('APIキーを入力してください');

  // enforce minimum interval between calls
  const gap = CALL_GAP - (Date.now() - lastCallAt);
  if(gap > 0) {
    const s = Math.ceil(gap / 1000);
    setStatus(`⏳ 次のリクエストまで ${s}秒待機 (レート制限対策)`, 'warn');
    startCd(s);
    await new Promise(r => setTimeout(r, gap));
    stopCd();
  }

  for(let attempt = 0; attempt <= MAX_RETRY; attempt++) {
    lastCallAt = Date.now();
    let res, raw;

    try {
      const ctrl    = new AbortController();
      const timeout = setTimeout(() => ctrl.abort(), 30000);
      res = await fetch(ENDPOINT + '?key=' + key, {
        method:  'POST',
        headers: { 'Content-Type': 'application/json' },
        body:    JSON.stringify({
          contents:         [{ role:'user', parts:[{ text:prompt }] }],
          generationConfig: { temperature:0.35, maxOutputTokens:2000 }
        }),
        signal: ctrl.signal
      });
      clearTimeout(timeout);
      raw = await res.text();
    } catch(e) {
      // network / timeout error
      if(attempt < MAX_RETRY) {
        setStatus(`ネットワークエラー — 5秒後に再試行 (${attempt+1}/${MAX_RETRY})`, 'warn');
        await new Promise(r => setTimeout(r, 5000));
        continue;
      }
      throw new Error('ネットワーク接続エラー: ' + e.message);
    }

    // ── success ──
    if(res.ok) {
      let data;
      try { data = JSON.parse(raw); } catch(_) {
        throw new Error('Geminiの応答JSONが壊れています。再実行してください。');
      }
      const txt = data?.candidates?.[0]?.content?.parts?.[0]?.text;
      const reason = data?.candidates?.[0]?.finishReason || '';
      if(!txt) {
        if(reason === 'SAFETY')
          throw new Error('セーフティフィルターでブロックされました。質問の表現を変えてください。');
        throw new Error(`応答が空です (finishReason: ${reason || 'unknown'})`);
      }
      callCount++;
      el.meta.textContent = `このセッションのAPI呼び出し回数: ${callCount}`;
      return txt;
    }

    // ── error ──
    let apiMsg = `HTTP ${res.status}`;
    try { apiMsg = JSON.parse(raw).error?.message || apiMsg; } catch(_) {}

    if(res.status === 401 || res.status === 403)
      throw new Error(`認証エラー (${res.status}) — aistudio.google.com でAPIキーを再確認してください`);

    if(res.status === 429) {
      if(attempt < MAX_RETRY) {
        setStatus(`⚠ Rate Limit (429) — ${WAIT_429}秒待機後に自動リトライ (${attempt+1}/${MAX_RETRY})`, 'warn');
        startCd(WAIT_429);
        await new Promise(r => setTimeout(r, WAIT_429 * 1000));
        stopCd();
        lastCallAt = 0; // skip gap check after a long wait
        continue;
      }
      throw new Error('429 Rate Limit — 自動リトライに失敗しました。3分後に再実行してください。');
    }

    throw new Error(apiMsg);
  }
}

/* ─── MAIN ────────────────────────────────────────────── */
async function run() {
  if(running) return;

  const key = el.key();
  const q   = el.q();

  // validate inputs
  if(!key)
    return setStatus('APIキーを入力してください', 'err');
  if(!key.startsWith('AIza') || key.length < 35)
    return setStatus('キー形式エラー — AIzaSy... で始まる39文字のキーを確認してください', 'err');
  if(!q)
    return setStatus('質問・問題を入力してください', 'err');

  // check cache
  const cKey   = PFX + btoa(encodeURIComponent(q)).slice(0, 40);
  const cached = cacheGet(cKey);
  if(cached) {
    renderResult(cached);
    setStatus('✓ キャッシュから取得しました', 'ok');
    return;
  }

  // start run
  running = true;
  el.btn.disabled = true;
  setStatus('分析中...', '');
  Object.values(el.agents).forEach(id => setLoading(id));

  try {
    /* ── CALL 1: 4エージェント同時分析（1回のAPIコールで取得）────────── */
    setStatus('1/2: 4エージェントが分析中...', '');
    const raw1 = await callGemini(
`あなたは4つの専門的視点を持つ戦略AIです。
以下の問いに対して、4つの視点それぞれで具体的な分析を行い、JSONのみで回答してください。
マークダウン・コードブロック・説明文は一切不要です。JSONオブジェクトのみ出力してください。

問い: ${q}

出力形式（各フィールドには実際の分析内容を150〜200文字で記述すること。テンプレート文をそのまま返すのは禁止）:
{
  "alpha": "[戦略的視点: 競争優位・差別化・スケーラビリティの観点から分析した内容]",
  "beta":  "[実務的視点: 具体的な実行ステップ・必要リソース・優先順位の観点から分析した内容]",
  "gamma": "[批評的視点: リスク・盲点・反論・失敗シナリオの観点から分析した内容]",
  "delta": "[原理的視点: 本質・構造・根本原因の観点から分析した内容]"
}`
    );

    const agents = safeJSON(raw1);

    // validate: both structure and content
    if(!agents?.alpha || !agents?.beta || !agents?.gamma || !agents?.delta)
      throw new Error('エージェント分析のJSONパースに失敗しました。\n\n応答の先頭: ' + raw1.slice(0, 200));

    if(['alpha','beta','gamma','delta'].some(k => isPlaceholder(agents[k])))
      throw new Error('Geminiがテンプレート文をそのまま返しました。もう一度実行してください。');

    setText('el_a', agents.alpha);
    setText('el_b', agents.beta);
    setText('el_c', agents.gamma);
    setText('el_d', agents.delta);
    setLoading('el_o');

    /* ── CALL 2: Ω 統合判断 ──────────────────────────────────────────── */
    setStatus('2/2: Ω統合判断を生成中...', '');
    const raw2 = await callGemini(
`以下の4つの専門的視点による分析を統合し、意思決定者が今日から行動できる統合判断を示してください。

問い: ${q}

α戦略: ${agents.alpha}
β実務: ${agents.beta}
γ批評: ${agents.gamma}
δ原理: ${agents.delta}

出力形式: プレーンテキスト（JSONは不要）。以下の構成で400文字以内にまとめること。
【結論】1〜2文で最も重要な判断を述べる
【根拠】3つの主要な根拠を簡潔に列挙
【今日のアクション】24時間以内に取るべき最優先アクション1つを具体的に指示`
    );

    const omega = raw2?.trim() || '統合判断を生成できませんでした。再実行してください。';
    setText('el_o', omega);

    const result = { alpha:agents.alpha, beta:agents.beta, gamma:agents.gamma, delta:agents.delta, omega };
    cacheSet(cKey, result);
    setStatus('✓ 完了', 'ok');

  } catch(e) {
    setStatus('⚠ ' + e.message, 'err');
    // clear any still-loading agents
    Object.values(el.agents).forEach(id => {
      if($(id)?.classList.contains('loading')) setText(id, '');
    });
  }

  running = false;
  el.btn.disabled = false;
}

function renderResult(r) {
  setText('el_a', r.alpha);
  setText('el_b', r.beta);
  setText('el_c', r.gamma);
  setText('el_d', r.delta);
  setText('el_o', r.omega);
}
</script>
</body>
</html>
